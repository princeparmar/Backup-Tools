name: Deploy to Windows Server

on:
  push:
    tags:
      - 'v*' # Trigger on version tags (e.g., v1.0.0, v2.1.3)
  workflow_dispatch: # Manual trigger

env:
  APP_NAME: 'backuptools-windows-amd64.exe'
  APP_PROCESS_NAME: 'backuptools-windows-amd64'
  DEPLOY_DIR: 'D:\bin'
  SERVICE_NAME: 'backuptools'
  GO_VERSION: '1.21.13'

jobs:
  deploy:
    runs-on: self-hosted
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: false
          
      - name: Build application
        run: |
          go mod download
          go build -o ${{ env.APP_NAME }} -ldflags="-s -w" ./cmd
          
      - name: Prepare deployment directory
        run: |
          if (!(Test-Path "${{ env.DEPLOY_DIR }}")) {
            New-Item -ItemType Directory -Path "${{ env.DEPLOY_DIR }}" -Force
          }
          
      - name: Stop and backup current version
        run: |
          # Stop service if running
          $service = Get-Service -Name "${{ env.SERVICE_NAME }}" -ErrorAction SilentlyContinue
          if ($service -and $service.Status -eq 'Running') {
            Stop-Service -Name "${{ env.SERVICE_NAME }}" -Force
            Write-Host "Service stopped"
          }
          
          # Backup existing application
          $appPath = "${{ env.DEPLOY_DIR }}\${{ env.APP_NAME }}"
          if (Test-Path $appPath) {
            $backupName = "${{ env.APP_NAME }}.backup.$(Get-Date -Format 'yyyyMMdd-HHmmss')"
            Copy-Item $appPath "${{ env.DEPLOY_DIR }}\$backupName" -Force
            Write-Host "Backup created: $backupName"
          }
          
      - name: Deploy new version
        run: |
          Copy-Item "${{ env.APP_NAME }}" "${{ env.DEPLOY_DIR }}\" -Force
          # Copy environment file if it exists
          if (Test-Path ".env") {
            Copy-Item ".env" "${{ env.DEPLOY_DIR }}\" -Force -ErrorAction SilentlyContinue
          }
          Write-Host "New version deployed to ${{ env.DEPLOY_DIR }}"
          
      - name: Start service and verify
        run: |
          # Try to start as service first
          $service = Get-Service -Name "${{ env.SERVICE_NAME }}" -ErrorAction SilentlyContinue
          if ($service) {
            try {
              Start-Service -Name "${{ env.SERVICE_NAME }}"
              Write-Host "Service started successfully"
            } catch {
              Write-Host "Service start failed: $($_.Exception.Message)"
            }
          }
          
          # Fallback: Start application directly
          Start-Sleep -Seconds 3
          $process = Get-Process -Name "${{ env.APP_PROCESS_NAME }}" -ErrorAction SilentlyContinue
          if (!$process) {
            Write-Host "Starting application directly..."
            Start-Process "${{ env.DEPLOY_DIR }}\${{ env.APP_NAME }}" -WorkingDirectory "${{ env.DEPLOY_DIR }}"
            Start-Sleep -Seconds 2
          }
          
          # Verification
          $process = Get-Process -Name "${{ env.APP_PROCESS_NAME }}" -ErrorAction SilentlyContinue
          if ($process) {
            Write-Host "✅ Deployment successful - PID: $($process.Id)"
          } else {
            Write-Host "❌ Deployment failed - application not running"
            exit 1
          }